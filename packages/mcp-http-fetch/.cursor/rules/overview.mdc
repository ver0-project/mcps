---
description: 'APPLY when working with mcp-http-fetch package TO understand package structure, architecture, available tools, and development guidelines'
globs:
alwaysApply: true
---
# MCP HTTP Fetch Package Overview

## Package Context

- **Name**: `@ver0/mcp-http-fetch`
- **Purpose**: MCP (Model Context Protocol) server that provides HTTP fetching capabilities as tools for AI assistants and applications
- **Repository**: Part of the `@ver0-project/mcps` monorepo
- **Entry Point**: `src/index.ts` - main MCP server setup
- **Build Target**: `dist/index.js` - compiled JavaScript output
- **Node Version**: Requires Node.js >= 22

## Architecture Overview

### Core Components

- **MCP Server**: Built using `@modelcontextprotocol/sdk` for protocol compliance
- **HTTP Fetching**: Uses native `fetch` API for HTTP operations
- **HTML Minification**: Uses `@minify-html/node` for HTML optimization
- **Markdown Conversion**: Uses `turndown` for HTML to markdown conversion
- **Type Safety**: Implements Zod schemas for input validation
- **Transport**: Uses stdio transport for communication with AI assistants

### Directory Structure

```
packages/mcp-http-fetch/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts          # Main server entry point and tool registration
â”‚   â”œâ”€â”€ types.ts          # Shared type definitions
â”‚   â””â”€â”€ tools/            # Individual HTTP fetch tool implementations
â””â”€â”€ package.json          # Package configuration
```

## Available HTTP Fetch Tools

The package implements the following HTTP fetch operations as MCP tools:

| Tool            | Status         | Description                                          |
| --------------- | -------------- | ---------------------------------------------------- |
| `fetch-html`    | âœ… Implemented | Fetch HTML content with optional minification and content limiting |
| `fetch-markdown`| âœ… Implemented | Fetch HTML and convert to markdown with content limiting |
| `fetch-json`    | ðŸš§ Planned     | Fetch and parse JSON content                         |

## Tool Implementation Pattern

Each HTTP fetch tool follows a consistent pattern:

- Implements Zod schema for parameter validation
- Uses native `fetch` API for HTTP operations
- Provides comprehensive error handling and response metadata
- Includes content-specific processing (e.g., HTML minification, markdown conversion)

## fetch-html Tool Features

### Automatic Headers
- **Accept**: Set to HTML types if not provided
- **User-Agent**: Set to browser-like string if not provided

### HTML Minification
- **Library**: `@minify-html/node` for fast, efficient minification
- **Condition**: Only applied when response content-type indicates HTML (text/html, application/xhtml+xml, application/xhtml)
- **Configuration**: Preserves template syntax, minifies CSS/JS, keeps compatibility
- **Metadata**: Reports original/minified lengths and compression ratio
- **Error Handling**: Falls back to original HTML if minification fails

### Content Limiting
- **Offset**: Skip specified number of characters from the beginning of HTML content
- **Limit**: Return only specified maximum number of characters from HTML content
- **Metadata**: Reports original content length, offset applied, and final content length
- **Token Efficiency**: Helps manage large HTML documents by limiting returned content

### Response Structure
- **Metadata**: Status, headers, URL, redirect info, minification stats, content limiting info
- **Content**: HTML (minified or original based on request, limited by start/end if specified)

## fetch-markdown Tool Features

### Automatic Headers
- **Accept**: Prioritizes markdown content types (`text/markdown`, `text/x-markdown`, `application/markdown`) then falls back to HTML types
- **User-Agent**: Set to browser-like string if not provided

### Markdown Conversion
- **Library**: `turndown` for high-quality HTML to markdown conversion
- **Global Instance**: Uses a shared, pre-configured TurndownService instance for optimal performance
- **Configuration**: ATX-style headings, fenced code blocks, proper formatting for emphasis and links
- **Custom Rules**: Enhanced support for strikethrough (`~~text~~`) and table formatting
- **Condition**: Only applied when response content-type indicates HTML content
- **Error Handling**: Falls back to original content if conversion fails

### Content Limiting
- **Start/End**: Same trimming functionality as fetch-html tool for token efficiency
- **Metadata**: Reports original content length, markdown conversion length, and applied trimming
- **Token Optimization**: Particularly useful for large HTML documents converted to markdown

### Response Structure
- **Metadata**: Status, headers, URL, redirect info, markdown conversion stats, content limiting info
- **Content**: Markdown (converted from HTML when applicable, limited by start/end if specified)

## Development Guidelines

- **Testing**: Each tool must have corresponding `.test.ts` file with comprehensive coverage
- **Validation**: Use Zod schemas for all tool parameters
- **Error Handling**: Provide meaningful error messages for HTTP operation failures
- **Types**: Maintain type safety throughout the codebase
- **Documentation**: Document all tool parameters and return values
- **Package management**: Use `yarn` for package management
- **Security**: Be cautious with external URLs and content processing

## Dependencies

### Runtime Dependencies

- `@modelcontextprotocol/sdk`: MCP protocol implementation
- `@minify-html/node`: Fast HTML minification
- `turndown`: HTML to markdown conversion
- `zod`: Schema validation

### Development Dependencies

- `@types/node`: Node.js type definitions
- `@types/turndown`: TypeScript definitions for turndown
- `typescript`: TypeScript compiler
- `vitest`: Testing framework
- `eslint`: Code linting

## Usage Context

This package is designed to be used as an MCP server that AI assistants can connect to for performing HTTP fetch operations. It provides a structured, validated interface for fetching and processing web content while maintaining type safety, proper error handling, and token efficiency through content optimization.

## Security Considerations

- Makes HTTP requests to external URLs
- No built-in authentication or authorization
- Consider network policies and firewall rules
- Be cautious with untrusted URLs and content
- Content processing (minification) is performed locally

